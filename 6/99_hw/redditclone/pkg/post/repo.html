
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">redditclone/pkg/post/collection_mock.go (85.7%)</option>
				
				<option value="file1">redditclone/pkg/post/cursor_mock.go (84.6%)</option>
				
				<option value="file2">redditclone/pkg/post/mongo.go (0.0%)</option>
				
				<option value="file3">redditclone/pkg/post/post.go (100.0%)</option>
				
				<option value="file4">redditclone/pkg/post/repo.go (100.0%)</option>
				
				<option value="file5">redditclone/pkg/post/single_result_mock.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package post

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
        options "go.mongodb.org/mongo-driver/mongo/options"
)

// MockCollection is an autogenerated mock type for the MockCollection type
type MockCollection struct {
        mock.Mock
}

// DeleteOne provides a mock function with given fields: _a0, _a1
func (_m *MockCollection) DeleteOne(_a0 context.Context, _a1 interface{}) error <span class="cov8" title="1">{
        ret := _m.Called(_a0, _a1)

        var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, interface{}) error); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// Find provides a mock function with given fields: _a0, _a1, _a2
func (_m *MockCollection) Find(_a0 context.Context, _a1 interface{}, _a2 ...*options.FindOptions) (CursorHelper, error) <span class="cov8" title="1">{
        _va := make([]interface{}, len(_a2))
        for _i := range _a2 </span><span class="cov8" title="1">{
                _va[_i] = _a2[_i]
        }</span>
        <span class="cov8" title="1">var _ca []interface{}
        _ca = append(_ca, _a0, _a1)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        var r0 CursorHelper
        if rf, ok := ret.Get(0).(func(context.Context, interface{}, ...*options.FindOptions) CursorHelper); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1, _a2...)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(CursorHelper)
                }</span>
        }

        <span class="cov8" title="1">var r1 error
        if rf, ok := ret.Get(1).(func(context.Context, interface{}, ...*options.FindOptions) error); ok </span><span class="cov0" title="0">{
                r1 = rf(_a0, _a1, _a2...)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// FindOne provides a mock function with given fields: _a0, _a1
func (_m *MockCollection) FindOne(_a0 context.Context, _a1 interface{}) SingleResultHelper <span class="cov8" title="1">{
        ret := _m.Called(_a0, _a1)

        var r0 SingleResultHelper
        if rf, ok := ret.Get(0).(func(context.Context, interface{}) SingleResultHelper); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(SingleResultHelper)
                }</span>
        }

        <span class="cov8" title="1">return r0</span>
}

// InsertOne provides a mock function with given fields: _a0, _a1
func (_m *MockCollection) InsertOne(_a0 context.Context, _a1 interface{}) error <span class="cov8" title="1">{
        ret := _m.Called(_a0, _a1)

        var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, interface{}) error); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// UpdateOne provides a mock function with given fields: _a0, _a1, _a2
func (_m *MockCollection) UpdateOne(_a0 context.Context, _a1 interface{}, _a2 interface{}) error <span class="cov8" title="1">{
        ret := _m.Called(_a0, _a1, _a2)

        var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, interface{}, interface{}) error); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0, _a1, _a2)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package post

import (
        context "context"

        mock "github.com/stretchr/testify/mock"
)

// MockCursor is an autogenerated mock type for the MockCursor type
type MockCursor struct {
        mock.Mock
}

// Close provides a mock function with given fields: _a0
func (_m *MockCursor) Close(_a0 context.Context) <span class="cov8" title="1">{
        _m.Called(_a0)
}</span>

// Decode provides a mock function with given fields: _a0
func (_m *MockCursor) Decode(_a0 interface{}) error <span class="cov8" title="1">{
        ret := _m.Called(_a0)

        var r0 error
        if rf, ok := ret.Get(0).(func(interface{}) error); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// Next provides a mock function with given fields: _a0
func (_m *MockCursor) Next(_a0 context.Context) bool <span class="cov8" title="1">{
        ret := _m.Called(_a0)

        var r0 bool
        if rf, ok := ret.Get(0).(func(context.Context) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(_a0)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov8" title="1">return r0</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package post

import (
        "context"

        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// Mongo is located here and not in the separate folder for convenience purposes

type SingleResultHelper interface {
        Decode(v interface{}) error
}

type CollectionHelper interface {
        Find(context.Context, interface{}, ...*options.FindOptions) (CursorHelper, error)
        FindOne(context.Context, interface{}) SingleResultHelper
        InsertOne(context.Context, interface{}) error
        UpdateOne(context.Context, interface{}, interface{}) error
        DeleteOne(context.Context, interface{}) error
}

type CursorHelper interface {
        Next(context.Context) bool
        Decode(interface{}) error
        Close(context.Context)
}

type mongoCollection struct {
        coll *mongo.Collection
}

type mongoSingleResult struct {
        res *mongo.SingleResult
}

type mongoCursor struct {
        cur *mongo.Cursor
}

func (c *mongoCollection) Find(ctx context.Context, filter interface{}, opts ...*options.FindOptions) (CursorHelper, error) <span class="cov0" title="0">{
        r, err := c.coll.Find(ctx, filter, opts...)
        return &amp;mongoCursor{cur: r}, err
}</span>

func (c *mongoCollection) FindOne(ctx context.Context, filter interface{}) SingleResultHelper <span class="cov0" title="0">{
        f := c.coll.FindOne(ctx, filter)
        return &amp;mongoSingleResult{res: f}
}</span>

func (c *mongoCollection) InsertOne(ctx context.Context, filter interface{}) error <span class="cov0" title="0">{
        _, err := c.coll.InsertOne(ctx, filter)
        return err
}</span>

func (c *mongoCollection) UpdateOne(ctx context.Context, filter interface{}, update interface{}) error <span class="cov0" title="0">{
        _, err := c.coll.UpdateOne(ctx, filter, update)
        return err
}</span>

func (c *mongoCollection) DeleteOne(ctx context.Context, filter interface{}) error <span class="cov0" title="0">{
        _, err := c.coll.DeleteOne(ctx, filter)
        return err
}</span>

func (s *mongoSingleResult) Decode(v interface{}) error <span class="cov0" title="0">{
        return s.res.Decode(v)
}</span>

func (c *mongoCursor) Next(ctx context.Context) bool <span class="cov0" title="0">{
        return c.cur.Next(ctx)
}</span>

func (c *mongoCursor) Decode(v interface{}) error <span class="cov0" title="0">{
        return c.cur.Decode(v)
}</span>

func (c *mongoCursor) Close(ctx context.Context) <span class="cov0" title="0">{
        c.cur.Close(ctx)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package post

import (
        "redditclone/pkg/comment"
        "redditclone/pkg/user"
        "time"
)

type Vote struct {
        UserId string `json:"user" bson:"user"`
        Vote   int    `json:"vote" bson:"vote"`
}

type Post struct {
        Score            int               `json:"score" bson:"score"`
        Views            int               `json:"views" bson:"views"`
        Type             string            `json:"type" bson:"type"`
        Title            string            `json:"title"  bson:"title"`
        Author           *user.User        `json:"author" bson:"author"`
        Category         string            `json:"category" bson:"category"`
        Text             string            `json:"text" bson:"text"`
        Url              string            `json:"url" bson:"url"`
        Votes            []Vote            `json:"votes" bson:"votes"`
        Comments         []comment.Comment `json:"comments" bson:"comments"`
        Created          time.Time         `json:"created" bson:"created"`
        UpvotePercentage int               `json:"upvotePercentage" bson:"upvotePercentage"`
        Id               string            `json:"id" bson:"id"`
}

func (p *Post) GetUpvotePercentage() int <span class="cov8" title="1">{
        cntMinus := 0
        cntPlus := 0
        for i := 0; i &lt; len(p.Votes); i++ </span><span class="cov8" title="1">{
                if p.Votes[i].Vote == -1 </span><span class="cov8" title="1">{
                        cntMinus += 1
                }</span> else<span class="cov8" title="1"> {
                        cntPlus += 1
                }</span>
        }
        <span class="cov8" title="1">if cntMinus+cntPlus == 0 </span><span class="cov8" title="1">{
                return 0
        }</span> else<span class="cov8" title="1"> {
                return (cntPlus * 100) / (cntMinus + cntPlus)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package post

import (
        "context"
        "errors"
        "redditclone/pkg/comment"
        "redditclone/pkg/random"
        "redditclone/pkg/user"
        "sync"
        "time"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type PostRepo struct {
        Collection CollectionHelper
        mu         *sync.RWMutex
        rn         *random.Generator
}

func NewRepo(ccol *mongo.Collection) *PostRepo <span class="cov8" title="1">{
        return &amp;PostRepo{
                Collection: &amp;mongoCollection{coll: ccol},
                mu:         &amp;sync.RWMutex{},
                rn:         random.NewGenerator(true),
        }
}</span>

func (p *PostRepo) GetAll() ([]*Post, error) <span class="cov8" title="1">{
        var result []*Post
        cur, _ := p.Collection.Find(context.TODO(), bson.M{}, options.Find())
        for cur.Next(context.TODO()) </span><span class="cov8" title="1">{
                var elem Post
                cur.Decode(&amp;elem)
                result = append(result, &amp;elem)
        }</span>
        <span class="cov8" title="1">cur.Close(context.TODO())
        return result, nil</span>
}

func (p *PostRepo) GetByCategory(category string) ([]*Post, error) <span class="cov8" title="1">{
        var result []*Post
        cur, _ := p.Collection.Find(context.TODO(), bson.M{"category": category})
        for cur.Next(context.TODO()) </span><span class="cov8" title="1">{
                var elem Post
                cur.Decode(&amp;elem)
                result = append(result, &amp;elem)
        }</span>
        <span class="cov8" title="1">cur.Close(context.TODO())
        return result, nil</span>
}

func (p *PostRepo) GetById(id string) (*Post, error) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        var result Post
        err := p.Collection.FindOne(context.TODO(), bson.M{"id": id}).Decode(&amp;result)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("User with given Id doesn't exist")
        }</span>
        <span class="cov8" title="1">return &amp;result, nil</span>
}

func (p *PostRepo) GetByUsername(username string) ([]*Post, error) <span class="cov8" title="1">{
        var result []*Post
        cur, _ := p.Collection.Find(context.TODO(), bson.M{"author.username": username})
        for cur.Next(context.TODO()) </span><span class="cov8" title="1">{
                var elem Post
                cur.Decode(&amp;elem)
                result = append(result, &amp;elem)
        }</span>
        <span class="cov8" title="1">cur.Close(context.TODO())
        return result, nil</span>
}

func (p *PostRepo) AddNewPost(user *user.User, newPost *Post) <span class="cov8" title="1">{
        newPost.Author = user
        newPost.Votes = []Vote{
                Vote{
                        UserId: newPost.Author.Id,
                        Vote:   1,
                },
        }
        newPost.Score = 1
        newPost.Views = 0
        newPost.Created = time.Now()
        newPost.UpvotePercentage = 100
        newPost.Comments = make([]comment.Comment, 0, 10)
        newPost.Id = p.rn.GetString()
        p.Collection.InsertOne(context.TODO(), newPost)
}</span>

func (p *PostRepo) AddPost(post *Post) <span class="cov8" title="1">{
        p.Collection.InsertOne(context.TODO(), post)
}</span>

func (p *PostRepo) AddCommentToPost(postId string, curUser *user.User, curComment comment.Comment) <span class="cov8" title="1">{
        curComment = comment.Comment{
                Created: time.Now(),
                Author:  curUser,
                Body:    curComment.Body,
                Id:      p.rn.GetString(),
        }
        filter := bson.M{"id": postId}
        update := bson.M{"$push": bson.M{"comments": curComment}}
        p.Collection.UpdateOne(context.TODO(), filter, update)
}</span>

func (p *PostRepo) PostUpvote(postId, curUserId string) <span class="cov8" title="1">{
        post, _ := p.GetById(postId)
        found := false
        for i := 0; i &lt; len(post.Votes); i++ </span><span class="cov8" title="1">{
                if post.Votes[i].UserId == curUserId </span><span class="cov8" title="1">{
                        if post.Votes[i].Vote == -1 </span><span class="cov8" title="1">{
                                post.Votes[i].Vote = 1
                                post.Score += 2
                                post.UpvotePercentage = post.GetUpvotePercentage()
                                found = true
                        }</span>
                }
        }
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                newVote := Vote{
                        UserId: curUserId,
                        Vote:   1,
                }
                post.Votes = append(post.Votes, newVote)
                post.Score += 1
                post.UpvotePercentage = post.GetUpvotePercentage()
        }</span>
        <span class="cov8" title="1">p.PostDelete(postId)
        p.AddPost(post)</span>
}

func (p *PostRepo) PostDownvote(postId, curUserId string) <span class="cov8" title="1">{
        post, _ := p.GetById(postId)
        found := false
        for i := 0; i &lt; len(post.Votes); i++ </span><span class="cov8" title="1">{
                if post.Votes[i].UserId == curUserId </span><span class="cov8" title="1">{
                        if post.Votes[i].Vote == 1 </span><span class="cov8" title="1">{
                                post.Votes[i].Vote = -1
                                post.Score -= 2
                                post.UpvotePercentage = post.GetUpvotePercentage()
                                found = true
                        }</span>
                }
        }
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                newVote := Vote{
                        UserId: curUserId,
                        Vote:   -1,
                }
                post.Votes = append(post.Votes, newVote)
                post.Score -= 1
                post.UpvotePercentage = post.GetUpvotePercentage()
        }</span>
        <span class="cov8" title="1">p.PostDelete(postId)
        p.AddPost(post)</span>
}

func (p *PostRepo) PostUnvote(postId, curUserId string) <span class="cov8" title="1">{
        post, _ := p.GetById(postId)
        eraseInd := -1
        for i := 0; i &lt; len(post.Votes); i++ </span><span class="cov8" title="1">{
                if post.Votes[i].UserId == curUserId </span><span class="cov8" title="1">{
                        if post.Votes[i].Vote == 1 </span><span class="cov8" title="1">{
                                post.Score -= 1
                        }</span> else<span class="cov8" title="1"> {
                                post.Score += 1
                        }</span>
                        <span class="cov8" title="1">eraseInd = i</span>
                }
        }
        <span class="cov8" title="1">if eraseInd != -1 </span><span class="cov8" title="1">{
                post.Votes = append(post.Votes[:eraseInd], post.Votes[eraseInd+1:]...)
                post.UpvotePercentage = post.GetUpvotePercentage()
        }</span>
        <span class="cov8" title="1">p.PostDelete(postId)
        p.AddPost(post)</span>
}

func (p *PostRepo) CommentDelete(postId, commentId, curUserId string) <span class="cov8" title="1">{
        post, _ := p.GetById(postId)
        for i, curComment := range post.Comments </span><span class="cov8" title="1">{
                if curComment.Author.Id == curUserId &amp;&amp; curComment.Id == commentId </span><span class="cov8" title="1">{
                        post.Comments = append(post.Comments[:i], post.Comments[i+1:]...)
                        break</span>
                }
        }
        <span class="cov8" title="1">p.PostDelete(postId)
        p.AddPost(post)</span>
}

func (p *PostRepo) PostDelete(postId string) <span class="cov8" title="1">{
        filter := bson.M{"id": postId}
        p.Collection.DeleteOne(context.TODO(), filter)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package post

import mock "github.com/stretchr/testify/mock"

// MockSingleResult is an autogenerated mock type for the MockSingleResult type
type MockSingleResult struct {
        mock.Mock
}

// Decode provides a mock function with given fields: v
func (_m *MockSingleResult) Decode(v interface{}) error <span class="cov8" title="1">{
        ret := _m.Called(v)

        var r0 error
        if rf, ok := ret.Get(0).(func(interface{}) error); ok </span><span class="cov8" title="1">{
                r0 = rf(v)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
